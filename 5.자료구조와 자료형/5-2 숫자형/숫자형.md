
16진수에서 한 자리는 0부터 15까지의 값을 나타낼 수 있습니다. 이때, 10부터 15까지는 A부터 F로 표시됩니다.

따라서, 2자리의 16진수 값인 "FF"는 다음과 같이 계산됩니다.

F는 15를 의미하므로, 첫 번째 자리는 15 × 16^1 = 240이 됩니다.
두 번째 자리도 F이므로, 두 번째 자리는 15 × 16^0 = 15가 됩니다.

이를 합치면, "FF"는 240 + 15 = 255를 나타내게 됩니다.

즉, 16진수 FF는 10진수에서 255를 나타냅니다.

---------------------------------------------------------------------------------

**숫자형**
-




모던 자바스크립트는 숫자를 나타내는 두 가지 자료형을 지원한다.

1. 일반적인 숫자 - 64비트 형식 IEEE-754(double precision floationg point number)배정밀도 부동소수점 숫자 에 저장한다.
2. 임의의 길이를 가진 정수 - BigInt


---------------------------------------------------------------------------------


**숫자를 입력하는 다양한 방법**

10억쓰기

    1e9 // 1과 9개의 0 
    'e'는 e 왼쪽의 수에 e 오른쪽에 있는 수만큼의 10의 거듭제곱을 곱하는 효과

1마이크로초(100만분의 1)표현
    1e-6; //1에서 왼쪽으로 6번 소수점 이동

---------------------------------------------------------------------------------

16진수, 2진수, 8진수

    16진수는 0x를 사용해 표현
    0xff // 255


    2진수는 0b를 사용해 표현
    0b11111111 // 255

    8진수는 0o를 사용해 표현
    0o377 // 7+ 7*8 + 3*8^2 = 255

자바스크립트에서 지원하는 진법은 3개입니다. 이 외의 진법을 사용하려면 함수 parseInt를 사용해야 합니다

---------------------------------------------------------------------------------

toString(base)

num.toString(base) 메서드는 base진법으로 num을 표현한 후, 이를 문자형으로 변환해 반환


    let num = 255;

    alert( num.toString(16) );  // ff
    alert( num.toString(2) );   // 11111111

base는 2에서 36까지 쓸 수 있는데, 기본값은 10입니다.

base별 유스 케이스는 다음과 같습니다.

base=16 – 16진수 색, 문자 인코딩 등을 표현할 때 사용합니다. 숫자는 0부터 9, 10 이상의 수는 A부터 F를 사용하여 나타냅니다.

base=2 – 비트 연산 디버깅에 주로 쓰입니다. 숫자는 0 또는 1이 될 수 있습니다.

base=36 – 사용할 수 있는 base 중 최댓값으로, 0..9와 A..Z를 사용해 숫자를 표현합니다. 알파벳 전체가 숫자를 나타내는 데 사용되죠. 36 베이스는 url을 줄이는 것과 같이 숫자로 된 긴 식별자를 짧게 줄일 때 유용합니다. 예시를 살펴봅시다.

alert( 123456..toString(36) ); // 2n9c

    +123456..toString(36)에 있는 점 두 개는 오타가 아닙니다. 위 예시처럼 숫자를 대상으로 메서드 toString을 직접 호출하고 싶다면 숫자 다음에 점 두 개 ..를 붙여야 합니다.
    123456.toString(36)처럼 점을 한 개만 사용하면, 첫 번째 점 이후는 소수부로 인식되어 에러가 발생할 수 있습니다. 점을 하나 더 추가하면 자바스크립트는 소수부가 없다고 판단하고 함수를 호출합니다.

    (123456).toString(36)도 가능합니다.

        123456을 36으로 나눈 몫과 나머지를 구합니다.

        123456 ÷ 36 = 3434 ... 12
        나머지 12는 36진수에서 C에 해당됩니다.
        몫인 3434를 36으로 나눈 몫과 나머지를 구합니다.

        3434 ÷ 36 = 95 ... 9
        나머지 14는 36진수에서 9에 해당됩니다.
        몫인 95를 36으로 나눈 몫과 나머지를 구합니다.

        95 ÷ 36 = 2 ... 23
        나머지 23은 36진수에서 N에 해당됩니다.
        몫인 2를 36으로 나눈 몫과 나머지를 구합니다.

        2 ÷ 36 = 0 ... 2
        나머지 2는 36진수에서 2에 해당됩니다.
        나머지를 역순으로 나열합니다.

        따라서 123456을 36진수로 변환한 결과는 "2n9c"가 됩니다.


---------------------------------------------------------------------------------

<br>

## 어림수 구하기<br><br>

Math.floor<br>
소수점 첫째 자리에서 내림(버림). 
3.1 -> 3, -1.1 -> -2


Math.ceil<br>

소수점 첫째 자리에서 올림
3.1 -> 4, -1.1 -> -1

Math.round<br>

소수점 첫째 자리에서 반올림
3.1 -> 3, -1.1 -> -1

Math.trunc (IE에서 지원 x )

소수부를 무시
3.1 -> 3, -1.1 -> -1
<br><br>


**소수점 n-th번째 수를 기준으로 어림수를 구해야 하는 상황**

ex) 1.2345가 있는데 소수점 두 번째 자릿수까지만 남겨 1.23을 만들고 싶은 경우

1. 곱하기와 나누기 


    let num = 1.23456;

    alert( Math.floor(num * 100) / 100 ); // <br>
    1.23456  <br>
    -> num * 100 = 123.45600002  <br>
    -> Math.floor(num * 100) = 123 <br>
    -> Math.floor(num * 100)/100 = 1.23<br><br>


2. 소수점 n 번째 수까지의 어림수를 구한 후 이를 문자형으로 반환해주는 메서드인 toFixed(n)를 사용

    let num = 12.34;<br>
    alert( num.toFixed(1) ); // "12.3"


    toFixed는 Math.round와 유사하게 가장 가까운 값으로 올림 혹은 버림해줍니다.

    toFixed를 사용할 때 주의할 점은 이 메서드의 반환 값이 문자열이라는 것입니다. 소수부의 길이가 인수보다 작으면 끝에 0이 추가됩니다.

    let num = 12.34;
    alert( num.toFixed(5) ); // "12.34000", 소수부의 길이를 5로 만들기 위해 0이 추가됨


참고로, +num.toFixed(5)처럼 단항 덧셈 연산자를 앞에 붙이거나 Number()를 호출하면 문자형의 숫자를 숫자형으로 변환할 수 있습니다.


---------------------------------------------------------------------------------
<br>

**부정확한 계산**

    - 숫자는 내부적으로 64비트 형식 IEEE-754으로 표현되기 때문에 숫자를 저장하려면 정확히 64비트가 필요합니다. 64비트 중 52비트는 숫자를 저장하는 데 사용되고, 11비트는 소수점 위치를(정수는 0), 1비트는 부호를 저장하는 데 사용


    - 숫자가 너무 커지면 64비트 공간이 넘쳐서 Infinity로 처리된다.
    이 원인 중 하나는 정밀도 손실(loss of precision)이다. 

    ex) console.log( 0.1 + 0.2 == 0.3 ); // false

    console.log( 0.1 + 0.2 ); // 0.30000000000004


    
    0.1은 1을 10으로 나눈 수인 1/10입니다. 10진법을 사용하면 이러한 숫자를 쉽게 표현할 수 있죠. 1/10과 1/3을 비교해봅시다. 1/3은 무한 소수 0.33333(3)이 됩니다.

    이렇듯 10진법에서 1/3을 정확히 나타낼 수 없듯이, 2진법을 사용해 0.1 또는 0.2를 정확하게 저장하는 방법은 없습니다

    IEEE-754에선 가능한 가장 가까운 숫자로 반올림하는 방법을 사용해 이런 문제를 해결합니다. 
    그런데 반올림 규칙을 적용하면 발생하는 '작은 정밀도 손실’을 우리가 볼 수는 없지만 실제로 손실은 발생합니다.

    아래와 같이 코드를 작성하면 정밀도 손실을 눈으로 확인할 수 있죠.
        alert( 0.1.toFixed(20) ); // 0.10000000000000000555


    그리고 두 숫자를 합하면 '정밀도 손실’도 더해집니다.
    0.1 + 0.2가 정확히 0.3이 아닌 이유가 여기에 있습니다.


        +자바스크립트뿐만이 아닙니다.
        다른 언어에서도 같은 이슈가 있습니다.

        자바스크립트와 동일한 숫자 형식을 사용하기 때문에 PHP, Java, C, Perl, Ruby에서도 똑같은 결과를 얻습니다.


문제 해결 방법

1. 가장 신뢰할만한 방법 - toFixed(n)메서드를 이용해 어림수 만들기

    toFixed(n)은 항상 문자열을 반환하기 때문에, 소수점 다음 숫자가 항상 2개가 될 수도 있다. <br>
    숫자형으로 강제 변환하려면 단항 덧셈연산자(+) 사용할 것<br><br>

2. 숫자에 임시로 100(혹은 더 큰 숫자)을 곱하여 정수로 바꾸고, 원하는 연산 후 다시 100으로 나누기.<br><br>
정수 수학연산은 소수대상 연산보다 에러가 적다.
but 마지막에 나눗셈이 들어와서 소수가 다시 등장할 수도 있는 단점이 있다. (에러를 줄여도 완전히 없애지는 못함)

    alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3 <br>
    alert( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001


무한소수를 방지하는 완벽한 방법은 사실 없습니다. 필요할 때마다 '꼬리’를 잘라 어림수를 만드는 방법뿐이죠.


>*+두 종류의 0* <br><br>
자바스크립트 내부에서 숫자를 표현하는 방식 때문에 발생하는 또 다른 흥미로운 현상은 0과 -0이라는 두 종류의 0이 존재한다는 사실입니다.<br>
자바스크립트에선 숫자의 부호가 단일 비트에 저장되는데 0을 포함한 모든 숫자에 부호를 설정할 수도, 설정하지 않을 수도 있기 때문입니다.



---------------------------------------------------------------------------------


### isNaN과 isFinite

<br>
Infinity와 -Infinity – 그 어떤 숫자보다 큰 혹은 작은 특수 숫자 값<br>
NaN – 에러를 나타내는 값<br><br>

**이들을 정상적인 숫자와 구분하기 위한 특별한 함수**

isNaN(value) - 인수를 숫자로 변환 후 NaN인지 테스트

    console.log( isNaN(NaN) ); // true
    console.log( isNaN("str) ); // true

NaN은 자기 자신을 포함해 그 어떤 값과도 같지 않기 때문에 isNaN함수 필요
    
    ex) NaN === NaN // false


isFinite(value) - 인수를 숫자로 변환 후 NaN/Infinity/-Infinity 가 아닌 일반 숫자일 경우 true 반환

    console.log( isFinite("str) ) // false - NaN이기 때문에

isFinite는 문자열이 일반 숫자인지 검증하는데 사용되곤 한다.<br>
빈 문자열이나 공백만 있는 문자열은 isFinite를 포함한 모든 숫자 관련 내장함수에서 0으로 취급된다. 

* * *

### parseInt와 parseFloat
<br>
단항 덧셈 연산자 + 또는 Number() 사용할 경우, 숫자형 변형 적용 규칙이 엄격하다.

    ex) console.log(+"100px"); // NaN

따라서 숫자만 추출하는 방법을 찾기 위해 parseInt와 parseFloat 제작<br>

두 함수는 불가능할 때까지 문자열에서 숫자를 '읽는다.'

    alert( parseInt('100px') ); // 100
    alert( parseFloat('12.5em') ); // 12.5

    alert( parseInt('12.3') ); // 12, 정수 부분만 반환됩니다.
    alert( parseFloat('12.3.4') ); // 12.3, 두 번째 점에서 숫자 읽기를 멈춥니다.


* * *

### 기타 수학 함수
<br>

**Math.random()**<br>
0과 1 사이 난수 반환(1 제외)

**Math.max(a, b, c..) / Math.min(a, b, c ...)**<br>
인수 중 최대/ 최솟값 반환

**Math.pow(n, power)**
<br> n을 power번 거듭제곱한 값 

* * *
### 요약


0이 많이 붙은 큰 숫자는 다음과 같은 방법을 사용해 씁니다.

- 0의 개수를 'e' 뒤에 추가합니다. 123e6은 0이 6개인 숫자, 123000000을 나타냅니다.
- 'e' 다음에 음수가 오면, 음수의 절댓값 만큼 10을 거듭제곱한 숫자로 주어진 숫자를 나눕니다. 123e-6은 0.000123을 나타냅니다.


다양한 진법 사용

- 특별한 변환 없이 16진수(0x), 8진수(0o), 2진수(0b)를 바로 사용할 수 있게 지원
- parseInt(str, base) 를 사용하면 str을 base 진수로 변환(단, 2 <= base <= 36)
- num.toString(base)는 숫자를 base진수로 바꾸고, 이를 문자열 형태로 반환

12pt나 100px과 같은 값 숫자 변환

- parseInt/parseFloat

소수 처리 메서드

- Math.floor, Math.ceil, Math.trunc, Math.round, num.toFixed(precision)
- 소수를 다룰 때는 정밀도 손실에 주의


이외 다양한 수학함수
https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math










































































